{"version":3,"file":"component---src-pages-truth-table-tsx-010e1700170535508221.js","mappings":"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","sources":["webpack://martials-website/./node_modules/react-feather/dist/icons/search.js","webpack://martials-website/./src/components/input.tsx","webpack://martials-website/./src/classes/operator.ts","webpack://martials-website/./src/classes/expression.ts","webpack://martials-website/./src/components/truth-table.tsx","webpack://martials-website/./src/pages/truth-table.tsx","webpack://martials-website/./node_modules/@babel/runtime/helpers/esm/objectDestructuringEmpty.js"],"sourcesContent":["function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nimport React, { forwardRef } from 'react';\nvar Search = forwardRef(function (_ref, ref) {\n  var _ref$color = _ref.color,\n      color = _ref$color === void 0 ? 'currentColor' : _ref$color,\n      _ref$size = _ref.size,\n      size = _ref$size === void 0 ? 24 : _ref$size,\n      rest = _objectWithoutProperties(_ref, [\"color\", \"size\"]);\n\n  return /*#__PURE__*/React.createElement(\"svg\", _extends({\n    ref: ref,\n    xmlns: \"http://www.w3.org/2000/svg\",\n    width: size,\n    height: size,\n    viewBox: \"0 0 24 24\",\n    fill: \"none\",\n    stroke: color,\n    strokeWidth: \"2\",\n    strokeLinecap: \"round\",\n    strokeLinejoin: \"round\"\n  }, rest), /*#__PURE__*/React.createElement(\"circle\", {\n    cx: \"11\",\n    cy: \"11\",\n    r: \"8\"\n  }), /*#__PURE__*/React.createElement(\"line\", {\n    x1: \"21\",\n    y1: \"21\",\n    x2: \"16.65\",\n    y2: \"16.65\"\n  }));\n});\nSearch.displayName = 'Search';\nexport default Search;","import * as React from \"react\";\n\ninterface Input {\n    className?: string,\n    id?: string,\n    name?: string,\n    type?: string,\n    title?: string,\n    placeholder?: string,\n    required?: boolean,\n    onChange?: React.ChangeEventHandler<HTMLInputElement>,\n    leading?: React.ReactElement<HTMLElement>,\n    trailing?: React.ReactElement<HTMLElement>,\n}\n\nconst Input = ({ className, id, name, type, title, placeholder, required, onChange, leading, trailing }: Input) => {\n\n    const [isFocused, setIsFocused] = React.useState(false);\n    const [isHover, setIsHover] = React.useState(false);\n    const [isText, setIsText] = React.useState(false);\n\n    function setSetIsText() {\n        if (id) {\n            const el = document.getElementById(id) as HTMLInputElement;\n            setIsText(el.value !== \"\");\n        }\n    }\n\n    React.useEffect(() => {\n\n        let isMounted = true;\n\n        function hover(hover: boolean) {\n            if (isMounted) {\n                setIsHover(hover);\n            }\n        }\n\n        if (id) {\n            const el = document.getElementById(id);\n            if (el) {\n                el.addEventListener(\"pointerenter\", () => hover(true));\n                el.addEventListener(\"pointerleave\", () => hover(false));\n            }\n        }\n        return () => {\n            if (id) {\n                document.getElementById(id)?.removeEventListener(\"pointerenter\", () => hover(true));\n                document.getElementById(id)?.removeEventListener(\"pointerleave\", () => hover(false));\n            }\n            isMounted = false;\n        }\n    }, []);\n\n    return (\n        <div className={ \"flex flex-row items-center relative\" }>\n            { leading }\n            <HoverTitle title={ title } isActive={ isFocused || isHover || isText }/>\n            <input\n                className={ `dark:bg-gray-900 focus:border-primaryPurple outline-none border-2 border-gray-500 pl-2 ${ className }` }\n                id={ id }\n                onFocus={ () => setIsFocused(true) }\n                onBlur={ () => setIsFocused(false) }\n                name={ name }\n                type={ type }\n                placeholder={ placeholder }\n                required={ required }\n                onInput={ setSetIsText }\n                onChange={ onChange }/>\n            { trailing }\n        </div>\n    );\n}\n\nexport default Input;\n\ninterface TextArea {\n    className?: string,\n    id?: string,\n    name?: string,\n    title?: string,\n    placeholder?: string,\n    required?: boolean,\n    onChange?: React.ChangeEventHandler<HTMLTextAreaElement>\n}\n\nexport const TextArea = ({ className, id, name, title, placeholder, required = false, onChange }: TextArea) => {\n\n    const [isFocused, setIsFocused] = React.useState(false);\n    const [isHover, setIsHover] = React.useState(false);\n    const [isText, setIsText] = React.useState(false);\n\n    function setSetIsText() {\n        if (id) {\n            const el = document.getElementById(id) as HTMLTextAreaElement;\n            setIsText(el.value !== \"\");\n        }\n    }\n\n    React.useEffect(() => {\n\n        let isMounted = true;\n\n        function hover(hover: boolean) {\n            if (isMounted) {\n                setIsHover(hover);\n            }\n        }\n\n        if (id) {\n            const el = document.getElementById(id);\n            if (el) {\n                el.addEventListener(\"pointerenter\", () => hover(true));\n                el.addEventListener(\"pointerleave\", () => hover(false));\n            }\n        }\n        return () => {\n            if (id) {\n                document.getElementById(id)?.removeEventListener(\"pointerenter\", () => hover(true));\n                document.getElementById(id)?.removeEventListener(\"pointerleave\", () => hover(false));\n                isMounted = false;\n            }\n        }\n    }, []);\n\n    return ( // TODO expand textArea when typing\n        <div className={ \"relative\" }>\n            <HoverTitle title={ title } isActive={ isFocused || isHover || isText }/>\n            <textarea id={ id }\n                      className={ `pl-2 min-h-[3rem] dark:bg-gray-900 focus:border-primaryPurple outline-none\n                                   border-2 border-gray-500 ${ className }` }\n                      name={ name }\n                      placeholder={ placeholder }\n                      required={ required }\n                      onInput={ setSetIsText }\n                      onFocus={ () => setIsFocused(true) }\n                      onBlur={ () => setIsFocused(false) }\n                      onChange={ onChange }/>\n        </div>\n    );\n};\n\ninterface HoverTitle {\n    title?: string,\n    isActive?: boolean,\n}\n\nconst HoverTitle = ({ title, isActive = false }: HoverTitle) => {\n    return (\n        <span className={ `absolute pointer-events-none\n                 ${ isActive ? \"-top-2 left-3 bg-white dark:bg-gray-900 text-sm\" : \"left-2 top-1\" } \n            transition-all duration-150 text-gray-600 dark:text-gray-400` }>\n                <div className={ \"z-50 relative\" }>{ title }</div>\n                <div className={ \"w-full h-2 bg-white dark:bg-gray-900 absolute bottom-1/3 z-10\" }/>\n            </span>\n    );\n}\n","interface Values {\n    values?: string[],\n}\n\n// TODO remember strength: !, &, |, ->\n\nexport class Operator {\n\n    public constructor(operator: string, weight: number, { values = [] }: Values) {\n        this.operator = operator;\n        this.weight = weight;\n        this.values = values;\n    }\n\n    operator: string;\n    weight: number;\n    values: string[];\n\n    static implication = new Operator(\">\", 0, { values: [\"implication\", \"imp\", \"impliserer\", \"->\", \"=>\"] });\n    static or = new Operator(\"|\", 1, { values: [\"or\", \"eller\", \"V\", \"\\\\/\"] });\n    static and = new Operator(\"&\", 2, { values: [\"and\", \"og\", \"/\\\\\"] });\n    static not = new Operator(\"!\", 3, { values: [\"not\", \"ikke\", \"¬\", \"~\", \"-\"] });\n\n    public static getValues(): Operator[] {\n        return [Operator.implication, Operator.or, Operator.and, Operator.not];\n    }\n\n    public static getOperator(operator: string): Operator | null {\n        for (const value of Operator.getValues()) {\n            if (value.operator === operator) {\n                return value;\n            }\n        }\n        return null;\n    }\n\n    public static isOperator(char: string): boolean {\n        return this.getValues().some((value) => value.operator === char);\n    }\n\n    public append(val: string): void {\n        this.values[this.values.length] = val;\n    }\n\n    public toString(): string {\n        return this.operator;\n    }\n\n}\n","import { Operator } from \"./operator\";\n\nexport class Expression {\n\n    public constructor(exp1: Expression | string | null, operator: Operator | null, exp2: Expression | string | null, {\n        leading = \"\",\n        trailing = \"\",\n        isAtomic = false,\n    }) {\n        this.leading = leading;\n        this.exp1 = exp1;\n        this.operator = operator;\n        this.exp2 = exp2;\n        this.trailing = trailing;\n        this.isAtomic = isAtomic;\n    }\n\n    leading: string;\n    exp1: Expression | string | null;\n    operator: Operator | null;\n    exp2: Expression | string | null;\n    trailing: string;\n    isAtomic: boolean;\n\n    // TODO add weight to each Expression used to compare and sort, using the \"value\" of noth child Expressions, atomic uses string value\n\n    private _isString({\n                          exp1 = null,\n                          exp2 = null\n                      }: { exp1: Expression | string | null, exp2: Expression | string | null }): boolean {\n        let isString = false;\n        if (exp1 !== null) {\n            isString = typeof exp1 === \"string\";\n        }\n        if (exp2 !== null) {\n            isString = typeof exp2 === \"string\";\n        }\n        return isString;\n    }\n\n    /**\n     * Compared an object with an other object and returns true if they contain the same values\n     * @param other The object this is compared to\n     * @returns {boolean} If this and the other expressions are the same returns 'true' (regardless or order) otherwise 'false'\n     */\n    public equals(other: Expression | string): boolean {\n\n        if (this === other) { // If they are the same object, or a string with the same content, return true\n            return true;\n        }\n        else if (typeof this !== \"string\" && typeof other !== \"string\") {\n            if (this.isAtomic && other.isAtomic && this.exp1 === other.exp1) {\n                return true;\n            }\n            else if (!(this.isAtomic || other.isAtomic) && this.operator === other.operator) { // If neither is atomic\n\n                if (this._isString({ exp1: this.exp1, exp2: this.exp2 }) && this._isString({\n                    exp1: other.exp1,\n                    exp2: other.exp2\n                })) {\n\n                    if (this.exp1 === other.exp1 && this.exp2 === other.exp2 ||\n                        this.exp1 === other.exp2 && this.exp2 === other.exp1) {\n                        return true;\n                    }\n                }\n                else if (!(this._isString({ exp1: this.exp1, exp2: this.exp2 }) || this._isString({\n                    exp1: other.exp1,\n                    exp2: other.exp2\n                }))) {\n                    if (this.exp1 && this.exp2 && other.exp1 && other.exp2) {\n\n                        if ((this.exp1 as Expression).equals(other.exp1) && (this.exp2 as Expression).equals(other.exp2) ||\n                            (this.exp1 as Expression).equals(other.exp2) && (this.exp1 as Expression).equals(other.exp2)) {\n                            return true;\n                        }\n                    }\n                }\n            }\n        }\n        else { // One is a string while the other is an Expression\n\n            const isEqual = (exp1: Expression | string, exp2: Expression | string): boolean => {\n                return typeof exp1 === \"string\" && typeof exp2 !== \"string\" && exp1 === exp2.exp1;\n            };\n\n            if (isEqual(this, other) || isEqual(other, this)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public getAtomicValue(): string | null {\n        if (typeof this.exp1 === \"string\") {\n            return this.exp1;\n        }\n        else if (this.exp1 && this.exp1.isAtomic) {\n            return this.exp1.getAtomicValue();\n        }\n        return null;\n    }\n\n    public laws(): void {\n        this.absorption();\n        this.eliminationOfImplication();\n        this.deMorgansLaw();\n        this.assosiativeLaw();\n        this.commutativeLaw();\n        this.distributivity();\n        this.mergeNot();\n    }\n\n    /**\n     * @example A & B | B & C <=> B & (A | C)\n     */\n    public distributivity(): void {\n\n        if (this.exp1 && this.exp2 && typeof this.exp1 === \"object\" && typeof this.exp2 === \"object\" &&\n            !this.exp1.isAtomic && !this.exp2.isAtomic) {\n\n            const setObjects = (left: Expression | string, right: Expression | string, common: Expression | string | null): void => {\n                this.exp2 = new Expression(left, this.operator, right, {});\n                this.exp1 = new Expression(common, null, null, { isAtomic: true });\n                this.operator = this.operator === Operator.and ? Operator.or : Operator.and;\n\n                if (this.operator !== Operator.and) {\n                    if (!this.leading.includes(\"(\")) {\n                        this.leading += \"(\";\n                    }\n                    if (!this.trailing.includes(\")\")) {\n                        this.trailing += \")\";\n                    }\n                }\n                else { // exp2.operator === or\n                    if (!this.exp2.leading.includes(\"(\")) {\n                        this.exp2.leading = \"(\";\n                    }\n                    if (!this.exp2.trailing.includes(\")\")) {\n                        this.exp2.trailing = \")\";\n                    }\n                }\n            };\n\n            // TODO prettify!\n            if (this.exp1.exp1 && this.exp1.exp2 && this.exp2.exp1 && this.exp2.exp2) {\n                if ((this.exp1.exp1 as Expression).getAtomicValue() === (this.exp2.exp1 as Expression).getAtomicValue()) {\n                    setObjects(this.exp1.exp2, this.exp2.exp2, this.exp1.exp1);\n                }\n                else if ((this.exp1.exp1 as Expression).getAtomicValue() === (this.exp2.exp2 as Expression).getAtomicValue()) {\n                    setObjects(this.exp1.exp2, this.exp2.exp1, this.exp1.exp1);\n                }\n                else if ((this.exp1.exp2 as Expression).getAtomicValue() === (this.exp2.exp1 as Expression).getAtomicValue()) {\n                    setObjects(this.exp1.exp1, this.exp2.exp2, this.exp1.exp2);\n                }\n                else if ((this.exp1.exp2 as Expression).getAtomicValue() === (this.exp2.exp2 as Expression).getAtomicValue()) {\n                    setObjects(this.exp1.exp1, this.exp2.exp1, this.exp1.exp2);\n                }\n            }\n        }\n    }\n\n    /**\n     * @example !A & !B <=> !(A | B)\n     */\n    public deMorgansLaw(): void {\n\n        if (this.exp1 && this.exp2) {\n\n            if (this._isNot(this.exp1) && this._isNot(this.exp2)) {\n                let newOperator = null;\n\n                switch (this.operator) {\n                    case Operator.and:\n                        newOperator = Operator.or;\n                        break;\n                    case Operator.or:\n                        newOperator = Operator.and;\n                }\n\n                if (newOperator !== null) {\n                    this.exp1 = new Expression(this._removeNot(this.exp1), newOperator, this._removeNot(this.exp2), {\n                        leading: \"!(\",\n                        trailing: \")\"\n                    });\n                    this.operator = null;\n                    this.exp2 = null;\n                }\n            }\n        }\n    }\n\n    private _isNot(exp: Expression | string): boolean {\n        if (typeof exp === \"string\") {\n            return exp.charAt(0) === \"!\";\n        }\n        return exp.leading.includes(\"!\");\n    }\n\n    private _removeNot(exp: Expression | string): Expression | string {\n\n        if (typeof exp === \"string\") {\n            return exp.replace(\"!\", \"\");\n        }\n        exp.leading = exp.leading.replace(\"!\", \"\");\n        return exp;\n    }\n\n    public assosiativeLaw(): void {\n        // TODO?\n    }\n\n    public commutativeLaw(): void {\n\n        const swap = () => {\n            const help = this.exp1;\n            this.exp1 = this.exp2;\n            this.exp2 = help;\n        }\n\n        if (this.exp1 && this.exp2) {\n            if (typeof this.exp1 === \"string\" && typeof this.exp2 === \"string\" && this.exp1 > this.exp2) {\n                swap();\n            }\n            else if (typeof this.exp1 === \"object\" && typeof this.exp2 === \"object\" && this.exp1.isAtomic && this.exp2.isAtomic) {\n                const atomic1 = this.exp1.getAtomicValue();\n                const atomic2 = this.exp2.getAtomicValue();\n                if (atomic1 && atomic2 && atomic1 > atomic2) {\n                    swap();\n                }\n            }\n        }\n    }\n\n    /**\n     * @example A -> B <=> !A | B\n     */\n    public eliminationOfImplication(): void {\n\n        if (this.exp1 && this.exp2 && this.operator === Operator.implication) {\n\n            if (typeof this.exp1 !== \"string\") {\n                if (!this.exp1.isAtomic) {\n                    if (!this.exp1.leading.includes(\"(\")) {\n                        this.exp1.leading += \"(\";\n                    }\n                    if (!this.exp1.trailing.includes(\")\")) {\n                        this.exp1.trailing += \")\";\n                    }\n                }\n                this.exp1.leading = \"!\" + this.exp1.leading;\n            }\n            else {\n                this.exp1 = \"!\" + this.exp1;\n            }\n            this.operator = Operator.or;\n        }\n    }\n\n    /**\n     * @example A & (A | B) <=> A or A | (A & B) <=> A\n     */\n    public absorption(): void {\n\n        if (this.exp1 && this.exp2 && typeof this.exp1 !== \"string\" && typeof this.exp2 !== \"string\") {\n\n            const removeExp2 = (exp: Expression) => {\n                exp.leading = \"\";\n                exp.operator = null;\n                exp.exp2 = null;\n                exp.trailing = \"\";\n                exp.isAtomic = true;\n            };\n\n            if (this.exp1.isAtomic && this.exp2.isAtomic && this.exp1.getAtomicValue() === this.exp2.getAtomicValue()) {\n                removeExp2(this);\n            }\n            else if (this.exp1.isAtomic || this.exp2.isAtomic) { // eg: A | (A & B)\n\n                const contains = (exp1: Expression, exp2: string): boolean => {\n\n                    let correctOperators = this.operator === Operator.and && exp1.operator === Operator.or;\n                    if (!correctOperators) {\n                        correctOperators = this.operator === Operator.or && exp1.operator === Operator.and;\n                    }\n                    if (!correctOperators) {\n                        correctOperators = this.operator === Operator.implication;\n                    }\n\n                    return correctOperators && (typeof exp1.exp1 !== \"string\" && typeof exp1.exp2 !== \"string\" &&\n                        (exp2 === exp1.exp1?.getAtomicValue() || exp2 === exp1.exp2?.getAtomicValue()));\n                };\n\n                const removeRedundant = (exp1: Expression, exp2: Expression, func: Function): void => {\n                    const atomic = exp1.getAtomicValue();\n                    if (atomic && contains(exp2, atomic)) {\n                        if (typeof exp2.exp1 === \"object\" && exp2.exp1?.isAtomic && this.operator === Operator.implication) {\n\n                            if (exp2.operator === Operator.and) { // Removes the equal\n                                if (exp2.exp1?.getAtomicValue() === atomic) {\n                                    exp2.exp1 = exp2.exp2;\n                                }\n                                removeExp2(exp2);\n                            }\n                            else if (exp2.operator === Operator.or) { // Removes the unequal\n                                if (exp2.exp1?.getAtomicValue() !== atomic) {\n                                    exp2.exp1 = exp2.exp2;\n                                }\n                                removeExp2(exp2);\n                            }\n                        }\n                        else {\n                            func();\n                            removeExp2(this);\n                        }\n                    }\n                };\n\n                if (this.exp1.isAtomic) {\n                    removeRedundant(this.exp1, this.exp2, () => null);\n                }\n                else {\n                    removeRedundant(this.exp2, this.exp1, () => this.exp1 = this.exp2);\n                }\n            }\n            else { // Neither of the expressions are atomic, eg: (A & B) | (A & B)\n                if (this.exp1.equals(this.exp2)) {\n                    removeExp2(this);\n                }\n            }\n        }\n    }\n\n    /**\n     * @example !!A <=> A or !!!A <=> !A\n     */\n    public mergeNot(): void {\n        let index = 0;\n        while ( this.leading.charAt(index) === \"!\" ) {\n            index++;\n        }\n        if (index > 1) {\n            this.leading = this.leading.replace(/!/g, \"\");\n            if (index % 2 !== 0) {\n                this.leading = \"!\" + this.leading;\n            }\n        }\n        if (typeof this.exp1 !== \"string\") {\n            this.exp1?.mergeNot();\n        }\n        if (typeof this.exp2 !== \"string\") {\n            this.exp2?.mergeNot();\n        }\n    }\n\n    public toString(): string {\n        let s = this.leading;\n\n        if (this.exp1 !== null) {\n            s += this.exp1.toString();\n\n            if (this.operator !== null) {\n                s += \" \" + this.operator.toString();\n\n                if (this.exp2 !== null) {\n                    s += \" \" + this.exp2.toString();\n                }\n            }\n            s += this.trailing;\n        }\n        return s;\n    }\n}\n","import * as React from \"react\";\nimport { Expression } from \"../classes/expression\";\n\ninterface TruthTable {\n    expression: Expression,\n    className?: string,\n    id?: string,\n}\n\nconst TruthTable = ({ expression, className, id }: TruthTable) => {\n\n    let expressions: Expression[] = [];\n\n    function expToArray(exp: Expression | string | null) { // TODO\n\n        if (exp) {\n            if (typeof exp !== \"string\") {\n                expToArray(exp.exp1);\n                expToArray(exp.exp2);\n\n                expressions.push(exp);\n            }\n            else {\n\n            }\n        }\n    }\n\n    return (\n        <div className={ `${ className }` } id={ id }>\n\n        </div>\n    )\n};\n\nexport default TruthTable;\n","import * as React from \"react\";\nimport Layout from \"../components/layout\";\nimport Input from \"../components/input\";\nimport { graphql } from \"gatsby\";\nimport { Expression } from \"../classes/expression\";\nimport { Operator } from \"../classes/operator\";\nimport { Search } from \"react-feather\";\nimport TruthTable from \"../components/truth-table\";\n\ninterface TruthTablePage {\n\n}\n\n/**\n * Takes in a string representation of a truth expression, then simplified it after multiple known laws.\n * @param stringExp The string that will be attempted simplified\n * @returns {string} A simplified string\n */\nexport function simplify(stringExp: string): string {\n    // TODO parse string and remove all unnecessarry parenthesis, if needed\n    const isLegal = isLegalExpression(stringExp);\n    return isLegal ? removeOuterParentheses(simplifyRec(stringExp).toString()) : stringExp;\n}\n\nfunction simplifyRec(stringExp: string): Expression {\n\n    // Basis\n    if (stringExp.length < 3) {\n        let leading = \"\";\n        if (stringExp.includes(\"!\")) {\n            stringExp = stringExp.replace(\"!\", \"\");\n            leading = \"!\";\n        }\n        return new Expression(stringExp, null, null, { leading: leading, isAtomic: true });\n    }\n\n    const exp = new Expression(null, null, null, {});\n\n    if (stringExp[0] === \"!\" && isOuterParentheses(stringExp.substring(1, stringExp.length))) { // TODO what if several !!!!\n        stringExp = stringExp.replace(\"!\", \"\");\n        exp.leading = \"!\";\n    }\n\n    const oldStringLen = stringExp.length;\n    stringExp = removeOuterParentheses(stringExp);\n\n    if (oldStringLen !== stringExp.length) {\n        exp.leading += \"(\";\n        exp.trailing += \")\";\n    }\n\n    const center = getCenterOperatorIndex(stringExp);\n\n    exp.exp1 = simplifyRec(stringExp.substring(0, center.index)); // Left\n    exp.operator = center.operator;\n    exp.exp2 = simplifyRec(stringExp.substring(center.index + 1, stringExp.length)); // Right\n\n    exp.laws();\n    return exp;\n}\n\n/**\n * Iterates through the string and finds the outer most center operator, if there are two, the one with the lowest weight is picked.\n * If they have the same weight the one to the right is picked.\n * @param stringExp A truth expression as a string, with no spaces between characters\n * @returns {number} The index position of the center operator based on the weight of the operators\n */\nfunction getCenterOperatorIndex(stringExp: string): any {\n\n    stringExp = removeOuterParentheses(stringExp);\n\n    let index = 0;\n    const arr: any[] = [];\n    for (let i = 0; i < stringExp.length; i++) {\n\n        let operators = 0;\n        try {\n            // Skips all lines within parenthesis\n            let c = stringExp.charAt(i);\n            while ( c === \"(\" || operators > 0 ) {\n                c = stringExp.charAt(i);\n                if (c === \"(\") {\n                    operators++;\n                }\n                else if (c === \")\") {\n                    operators--;\n                }\n                i++;\n            }\n        }\n        catch (error) {\n            console.error(error);\n        }\n\n        // Finds the matching Operator\n        const operator = Operator.getOperator(stringExp.charAt(i));\n        if (operator && operator !== Operator.not) {\n            arr[index++] = { operator: operator, index: i };\n        }\n    }\n\n    let op = arr[Math.floor(arr.length / 2)];\n\n    // If even, use the one with the lowest weight\n    if (arr.length % 2 === 0) {\n\n        let secondOp = arr[Math.floor(arr.length / 2 - 1)];\n        if (op.operator.weight > secondOp.operator.weight) {\n            op = secondOp;\n        }\n    }\n    return op;\n}\n\n/**\n * TODO illegal if two or more operators are following eachother, or if ! is before an operator\n * @param stringExp\n */\nfunction isLegalExpression(stringExp: string): boolean {\n\n    let operators: string[] = [];\n    for (let i = 0; i < Operator.getValues().length; i++) {\n        if (Operator.getValues()[i] !== Operator.not) {\n            operators[i] = Operator.getValues()[i].operator;\n        }\n    }\n\n    // If the first or las index is an operator, return false\n    if (operators.some((value) => value === stringExp.charAt(0) || value === stringExp.charAt(stringExp.length - 1))) {\n        console.error(\"Illegal input!\");\n        return false;\n    }\n\n    for (let i = 1; i < stringExp.length - 1; i++) {\n        if (stringExp.charAt(i) === Operator.not.operator) {\n            continue;\n        }\n        if (Operator.isOperator(stringExp.charAt(i)) && Operator.isOperator(stringExp.charAt(i - 1))) {\n            console.error(\"Illegal input!\");\n            return false;\n        }\n    }\n\n    return true;\n}\n\nfunction removeOuterParentheses(stringExp: string): string {\n    return isOuterParentheses(stringExp) ? stringExp.substring(1, stringExp.length - 1) : stringExp;\n}\n\nfunction isOuterParentheses(stringExp: string): boolean {\n    let operators = 0;\n    let is = false;\n\n    if (stringExp.charAt(0) === \"(\") {\n        is = true;\n    }\n    let index = 0;\n    while ( is && (stringExp.charAt(index) === \"(\" || operators > 0) ) {\n        if (stringExp.charAt(index) === \"(\") {\n            operators++;\n        }\n        else if (stringExp.charAt(index) === \")\") {\n            operators--;\n            if (operators === 0 && index !== stringExp.length - 1) {\n                is = false;\n            }\n        }\n        index++;\n    }\n    return is;\n}\n\n// TODO? neccessarry?\nfunction removeUnnessesarryParentheses(stringExp: string): string {\n    let operators = 0;\n    let parenthesesAroundExp = false;\n\n    let leftPIndex = -1;\n    let removeParentheses = false;\n\n    if (stringExp.charAt(0) === \"(\") {\n        parenthesesAroundExp = true;\n    }\n    let index = 0;\n    while ( stringExp.charAt(index) === \"(\" || operators > 0 ) {\n        if (leftPIndex !== -1) {\n            const operator = Operator.getOperator(stringExp.charAt(index));\n            // TODO use Expression instead?\n            switch (operator) {\n                case Operator.and:\n                    removeParentheses = true;\n                    break;\n                case Operator.or:\n                case Operator.implication:\n                case Operator.not:\n            }\n        }\n\n        if (stringExp.charAt(index) === \"(\") {\n            operators++;\n            leftPIndex = index;\n        }\n        else if (stringExp.charAt(index) === \")\") {\n            operators--;\n            if (leftPIndex !== -1 && removeParentheses) {\n                stringExp = stringExp.substring(0, leftPIndex) + stringExp.substring(index + 1, stringExp.length);\n            }\n            if (operators === 0 && index !== stringExp.length - 1) {\n                parenthesesAroundExp = false;\n            }\n        }\n        index++;\n    }\n    return stringExp;\n}\n\n// TODO translate\n// TODO generate truth tables\n// TODO simplify truth expressions\nconst TruthTablePage = ({}: TruthTablePage) => {\n\n    /**\n     * The state element used to store the simplified string, \"empty string\" by default\n     */\n    const [search, setSearch] = React.useState(\"\");\n\n    /**\n     * Updates the state of the current expression to the new search with all whitespace removed.\n     * If the element is not found, reset.\n     */\n    function onClick() {\n        let exp = (document.getElementById(\"truth-input\") as HTMLInputElement | null)?.value;\n        if (exp) {\n            exp = exp.replace(/\\s+/g, \"\"); // Replace All (/g) whitespace (/s) in the string\n            setSearch(simplify(exp));\n        }\n        else {\n            setSearch(\"\");\n        }\n    }\n\n    React.useEffect(() => {\n\n        let isMounted = true;\n\n        function keyPress(e: KeyboardEvent) {\n            if (isMounted && e.key === \"Enter\") {\n                const el = document.getElementById(\"truth-input-button\");\n                if (el) {\n                    el.click();\n                }\n            }\n        }\n\n        const el = document.getElementById(\"truth-input\");\n        if (el) {\n            el.addEventListener(\"keypress\", (e) => keyPress(e));\n        }\n        return () => {\n            if (el) {\n                el.removeEventListener(\"keypress\", (e) => keyPress(e));\n            }\n            isMounted = false;\n        };\n    }, []);\n\n    return (\n        <Layout title={ \"Truth tables\" } description={ \"Generate truth tables or simplify\" }>\n            <div className={ \"pt-2\" }>\n                <Input className={ `rounded-xl !pl-7 h-10` }\n                       id={ \"truth-input\" }\n                       title={\"A&B>C\"}\n                       leading={ <Search className={ \"pl-2 absolute\" }/> }\n                       trailing={\n                           <button id={ \"truth-input-button\" }\n                                   className={ \"ml-1 px-1 border border-gray-500 rounded-xl shadow shadow-primaryPurple h-10\" }\n                                   onClick={ onClick }>\n                               Simplify\n                           </button> }/>\n                <p>Output: { search }</p>\n                <TruthTable/>\n            </div>\n        </Layout>\n    );\n}\n\nexport const query = graphql`\n    query($language: String!) {\n        locales: allLocale(filter: {language: {eq: $language}}) {\n            edges {\n                node {\n                    ns\n                    data\n                    language\n                }\n            }\n        }\n    }\n`;\n\nexport default TruthTablePage;\n","export default function _objectDestructuringEmpty(obj) {\n  if (obj == null) throw new TypeError(\"Cannot destructure undefined\");\n}"],"names":["_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","this","_objectWithoutProperties","excluded","sourceKeys","keys","indexOf","_objectWithoutPropertiesLoose","getOwnPropertySymbols","sourceSymbolKeys","propertyIsEnumerable","Search","forwardRef","_ref","ref","_ref$color","color","_ref$size","size","rest","xmlns","width","height","viewBox","fill","stroke","strokeWidth","strokeLinecap","strokeLinejoin","cx","cy","r","x1","y1","x2","y2","displayName","className","id","name","type","title","placeholder","required","onChange","leading","trailing","React","isFocused","setIsFocused","isHover","setIsHover","isText","setIsText","isMounted","hover","el","document","getElementById","addEventListener","removeEventListener","HoverTitle","isActive","onFocus","onBlur","onInput","value","TextArea","Operator","operator","weight","values","getValues","implication","or","and","not","getOperator","isOperator","char","some","append","val","toString","Expression","exp1","exp2","isAtomic","_proto","_isString","isString","equals","other","isEqual","getAtomicValue","laws","absorption","eliminationOfImplication","deMorgansLaw","assosiativeLaw","commutativeLaw","distributivity","mergeNot","setObjects","left","right","common","_this","includes","_isNot","newOperator","_removeNot","exp","charAt","replace","swap","help","_this2","atomic1","atomic2","removeExp2","removeRedundant","func","atomic","correctOperators","_this3","_exp1$exp","_exp1$exp2","contains","_exp2$exp","index","s","expression","simplify","stringExp","isLegal","operators","console","error","isLegalExpression","removeOuterParentheses","simplifyRec","isOuterParentheses","substring","center","arr","c","op","Math","floor","secondOp","getCenterOperatorIndex","is","obj","TypeError","_objectDestructuringEmpty","search","setSearch","keyPress","e","click","Layout","description","Input","onClick","_document$getElementB","TruthTable"],"sourceRoot":""}